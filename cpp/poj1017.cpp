// poj1017.cpp : 定义控制台应用程序的入口点。
//

//#include "stdafx.h"
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
	int b1, b2, b3, b4, b5, b6; //不同大小的木块个数
	int nTotal = 0;             //最少需要的箱子数目
	int c1;						//当前能放 1*1 木块的空格数目
	int c2;						//当前能放 2*2 木块的空格数目
	int Contain2[4] = { 0, 5, 3, 1 }; //记录被3*3的占用之后，还剩多少给2*2的使用  
	while (cin >> b1 >> b2 >> b3 >> b4 >> b5 >> b6, b1 || b2 || b3 || b4 || b5 || b6)
	{
		nTotal = b6 + b5 + b4 + (b3 + 3) / 4; //只能装1个6*6的，1个5*5的，1个4*4的，
										      //而3*3的需要多情况考虑，3*3的需要向上调整
		                                      //这里有一个小技巧 (b3+3)/4 
										      //正好等于b3除以4向上取整的结果,下同 
		c2 = 5 * b4 + Contain2[b3 % 4]; //放2*2的数目等于放一个4*4时需要5个2*2加上
									    //放1到4个3*3时各需要的数目 ，即还可以装多少个2*2的  
		if (b2 > c2)    
			nTotal += (b2 - c2 + 8) / 9;  //向上调整 ，总的2*2的个数减去装过的2*2的个数，
										  //得到剩余的2*2的个数，
										  //此个数加上8然后除以9就正好等于它除以9向上取整的结果，
										  //之所以总数要加上这个数是由于若单独装2*2，可以装9个
		c1 = 36 * nTotal - 36 * b6 - 25 * b5 - 16 * b4 - 9 * b3 - 4 * b2; //还可以装多少个1*1的 
		if (b1 > c1)    
			nTotal += (b1 - c1 + 35) / 36; //向上调整,总的1*1的个数减去装过的1*1的个数，
										   //得到剩余的1*1的个数，
										   //此个数加上35然后除以36就正好等于它除以36向上取整的结果
										   //之所以总数要加上这个数是由于若单独装1*1，可以装36个
		cout << nTotal << endl;
	}
	//system("pause");
	return 0;
}
